import tkinter as tk                                # — Importa tkinter con alias `tk` (widgets básicos y raíz)
from tkinter import ttk, messagebox                 # — Importa ttk (widgets estilizados) y messagebox (diálogos)
from random import randint, uniform                 # — Importa randint (enteros) y uniform (float dentro de rango)

LANG = {                                            # — Diccionario de textos para internacionalización (inglés/español)
    "en": {
        "title": "Random Number Generator",
        "label_start": "Start number:",
        "label_end": "End number:",
        "label_type": "Number type:",
        "type_int": "Integer",
        "type_dec": "Decimal",
        "label_decimals": "Decimals (only for decimal):",
        "btn_generate": "Generate",
        "btn_clear": "Clear",
        "btn_history": "History",
        "btn_exit": "Exit",
        "result": "Result:",
        "err_invalid": "Please enter valid numbers.",
        "err_decimals": "Decimals must be a non-negative integer.",
        "history_title": "Generated Numbers History",
        "history_empty": "(history is empty)",
        "lang_label": "Language:",
        "btn_copy": "Copy",
    },
    "es": {
        "title": "Generador de Números Aleatorios",
        "label_start": "Número inicial:",
        "label_end": "Número final:",
        "label_type": "Tipo de número:",
        "type_int": "Entero",
        "type_dec": "Con coma",
        "label_decimals": "Decimales (solo para decimales):",
        "btn_generate": "Generar",
        "btn_clear": "Limpiar",
        "btn_history": "Historial",
        "btn_exit": "Salir",
        "result": "Resultado:",
        "err_invalid": "Por favor ingrese números válidos.",
        "err_decimals": "Los decimales deben ser un entero no negativo.",
        "history_title": "Historial de Números Generados",
        "history_empty": "(historial vacío)",
        "lang_label": "Idioma:",
        "btn_copy": "Copiar",
    }
}

def normalize_number_text(text: str) -> str:
    if text is None:
        return ""                                      # — Si la entrada es None, devuelve cadena vacía
    return text.strip().replace(",", ".")             # — Quita espacios al inicio/fin y convierte comas a punto

def parse_float_safe(text: str):
    normalized = normalize_number_text(text)         # — Normaliza el texto (trim y coma->punto)
    return float(normalized)                         # — Convierte a float (lanza excepción si inválido)

def parse_int_safe(text: str):
    normalized = normalize_number_text(text)         # — Normaliza el texto
    return int(float(normalized))                    # — Convierte a float y luego a int (trunca si hay decimales)

class RandomGeneratorApp:
    def __init__(self, root):
        self.root = root                             # — Guarda la raíz de Tkinter
        self.lang = "en"                             # — Idioma por defecto (clave en LANG)
        self.history = []                             # — Lista para historial de números generados
        self.history_window = None                    # — Referencia a la ventana de historial (si está abierta)

        # UI variables
        self.var_start = tk.StringVar()               # — Variable vinculada a entrada "start"
        self.var_end = tk.StringVar()                 # — Variable vinculada a entrada "end"
        self.type_var = tk.StringVar(value="Integer")# — Variable para tipo (Integer/Decimal), valor por defecto "Integer"
        self.var_decimals = tk.StringVar(value="2")   # — Variable para número de decimales (cadena), por defecto "2"
        self.var_result = tk.StringVar(value=LANG[self.lang]["result"])  # — Variable que muestra el resultado (texto inicial "Result:")
        self.lang_var = tk.StringVar(value=self.lang) # — Variable vinculada al selector de idioma (valor por defecto "en")

        self.build_ui()                               # — Construye la interfaz gráfica
        self.update_texts()                           # — Actualiza textos de la UI según LANGUAGE actual

    def build_ui(self):
        root = self.root
        root.title(LANG[self.lang]["title"])          # — Título de la ventana según idioma
        root.resizable(False, False)                  # — No permite redimensionar la ventana
        root.geometry("420x420")                      # — Tamaño fijo inicial de la ventana

        top_frame = ttk.Frame(root)                   # — Frame superior para selector de idioma
        top_frame.pack(fill="x", pady=8, padx=10)
        ttk.Label(top_frame, text=LANG[self.lang]["lang_label"]).pack(side="left")  # — Etiqueta "Idioma:"
        lang_menu = ttk.OptionMenu(top_frame, self.lang_var, self.lang, "en", "es", command=self.on_language_change)
                                                     # — Menu desplegable para cambiar idioma; llama on_language_change
        lang_menu.pack(side="left", padx=6)

        form = ttk.Frame(root)                        # — Frame principal del formulario
        form.pack(fill="both", expand=True, padx=10)

        ttk.Label(form, text="").pack()               # — Spacer (etiqueta vacía)

        self.lbl_start = ttk.Label(form, text="")     # — Label para "start" (se llenará en update_texts)
        self.lbl_start.pack(anchor="w")
        self.entry_start = ttk.Entry(form, textvariable=self.var_start)  # — Entrada vinculada a var_start
        self.entry_start.pack(fill="x")

        self.lbl_end = ttk.Label(form, text="")       # — Label para "end"
        self.lbl_end.pack(anchor="w", pady=(8,0))
        self.entry_end = ttk.Entry(form, textvariable=self.var_end)      # — Entrada vinculada a var_end
        self.entry_end.pack(fill="x")

        self.lbl_type = ttk.Label(form, text="")      # — Label para tipo de número
        self.lbl_type.pack(anchor="w", pady=(8,0))
        type_frame = ttk.Frame(form)                  # — Frame para los radiobuttons de tipo
        type_frame.pack(anchor="w")
        self.rb_int = ttk.Radiobutton(type_frame, text="", variable=self.type_var, value="Integer")
                                                     # — Radiobutton para entero; texto fijado en update_texts
        self.rb_int.pack(side="left")
        self.rb_dec = ttk.Radiobutton(type_frame, text="", variable=self.type_var, value="Decimal")
                                                     # — Radiobutton para decimal
        self.rb_dec.pack(side="left", padx=8)

        self.lbl_decimals = ttk.Label(form, text="")  # — Label para decimales (solo cuando el tipo es Decimal)
        self.lbl_decimals.pack(anchor="w", pady=(8,0))
        self.entry_decimals = ttk.Entry(form, textvariable=self.var_decimals, width=6)
                                                     # — Entrada para número de decimales (cadena)
        self.entry_decimals.pack(anchor="w")

        btn_frame = ttk.Frame(form)                    # — Frame para botones de acción
        btn_frame.pack(pady=12)
        self.btn_generate = ttk.Button(btn_frame, text="", command=self.on_generate)
                                                     # — Botón Generar -> on_generate
        self.btn_generate.pack(side="left", padx=6)
        self.btn_clear = ttk.Button(btn_frame, text="", command=self.on_clear)
                                                     # — Botón Limpiar -> on_clear
        self.btn_clear.pack(side="left", padx=6)
        self.btn_history = ttk.Button(btn_frame, text="", command=self.open_history)
                                                     # — Botón Historial -> open_history (ventana Toplevel)
        self.btn_history.pack(side="left", padx=6)
        self.btn_exit = ttk.Button(btn_frame, text="", command=root.destroy)
                                                     # — Botón Salir -> destruye la ventana raíz
        self.btn_exit.pack(side="left", padx=6)

        self.lbl_result = ttk.Label(form, textvariable=self.var_result, font=("Arial", 12, "bold"))
                                                     # — Etiqueta que muestra el resultado, vinculada a var_result
        self.lbl_result.pack(pady=8)

        self.btn_copy = ttk.Button(form, text="", command=self.copy_result)
                                                     # — Botón Copiar -> copy_result (copia al portapapeles)
        self.btn_copy.pack(pady=4)

    def on_language_change(self, new_value=None):
        val = self.lang_var.get()                      # — Toma el valor actual del OptionMenu
        if val not in LANG:
            return                                     # — Si el valor no está en LANG, no hace nada
        self.lang = val                                # — Actualiza el idioma interno
        self.update_texts()                             # — Refresca textos de toda la UI

    def update_texts(self):
        t = LANG[self.lang]                            # — Diccionario de textos activos según idioma
        self.root.title(t["title"])                    # — Actualiza título de la ventana
        self.lbl_start.config(text=t["label_start"])   # — Actualiza etiqueta 'start'
        self.lbl_end.config(text=t["label_end"])       # — Actualiza etiqueta 'end'
        self.lbl_type.config(text=t["label_type"])     # — Actualiza etiqueta 'type'
        self.rb_int.config(text=t["type_int"])         # — Actualiza texto del radiobutton entero
        self.rb_dec.config(text=t["type_dec"])         # — Actualiza texto del radiobutton decimal
        self.lbl_decimals.config(text=t["label_decimals"])
        self.btn_generate.config(text=t["btn_generate"])
        self.btn_clear.config(text=t["btn_clear"])
        self.btn_history.config(text=t["btn_history"])
        self.btn_exit.config(text=t["btn_exit"])
        self.btn_copy.config(text=t["btn_copy"])
        current = self.var_result.get()                # — Texto actual del resultado (p.ej. "Result: 5")
        parts = current.split(":", 1)                  # — Separa en dos por el primer ":" para conservar sufijo (valor)
        suffix = parts[1].strip() if len(parts) > 1 else ""  # — Sufijo: la parte después de "Result:"
        if suffix:
            self.var_result.set(f"{t['result']} {suffix}")  # — Reemplaza prefijo "Result:" según idioma y conserva valor
        else:
            self.var_result.set(t["result"])           # — Si no hay sufijo, solo muestra el texto de resultado

    def on_generate(self):
        t = LANG[self.lang]                            # — Textos para mensajes/errores locales
        try:
            start_text = normalize_number_text(self.var_start.get())
                                                         # — Normaliza input start (strip + comma->dot)
            end_text = normalize_number_text(self.var_end.get())
                                                         # — Normaliza input end

            start = float(start_text)                  # — Convierte start a float (puede lanzar ValueError)
            end = float(end_text)                      # — Convierte end a float
            if start > end:
                start, end = end, start                # — Si el usuario invirtió los límites, los invierte para normalizar

            if self.type_var.get() == "Integer":       # — Ruta para enteros
                start_i = int(float(start))            # — Convierte start a int (asegura truncamiento consistente)
                end_i = int(float(end))                # — Convierte end a int
                if start_i > end_i:
                    start_i, end_i = end_i, start_i    # — Asegura orden correcto después de conversión a int
                number = randint(start_i, end_i)      # — Genera entero aleatorio inclusive
                display = str(number)                  # — Representación para mostrar/guardar en historial
            else:                                       # — Ruta para decimales
                try:
                    decimals = int(float(normalize_number_text(self.var_decimals.get())))
                                                     # — Normaliza la cadena de decimales y la convierte a int
                    if decimals < 0:
                        raise ValueError              # — Decimales negativos no permitidos
                except ValueError:
                    messagebox.showerror(t["err_decimals"], t["err_decimals"])
                    return                            # — En caso de decimales inválidos, muestra error y aborta

                number = uniform(start, end)          # — Genera float aleatorio en [start, end)
                display = f"{round(number, decimals):.{decimals}f}"
                                                     # — Formatea el número con el número de decimales solicitado

            self.var_result.set(f"{t['result']} {display}")  # — Actualiza etiqueta de resultado con el valor generado
            self.history.append({                       # — Inserta un diccionario con metadatos en el historial
                "number": display,
                "start": start,
                "end": end,
                "type": self.type_var.get(),
                "decimals": int(float(normalize_number_text(self.var_decimals.get())))
            })
            if self.history_window and tk.Toplevel.winfo_exists(self.history_window):
                self.refresh_history_window()          # — Si la ventana de historial está abierta, la refresca
        except Exception:
            messagebox.showerror(t["err_invalid"], t["err_invalid"])
                                                     # — Cualquier excepción en el try provoca diálogo de error

    def on_clear(self):
        self.var_start.set("")                         # — Borra entrada start
        self.var_end.set("")                           # — Borra entrada end
        self.var_decimals.set("2")                     # — Restaura decimales a 2
        self.var_result.set(LANG[self.lang]["result"]) # — Resetea texto de resultado al prefijo (sin valor)

    def open_history(self):
        if self.history_window and tk.Toplevel.winfo_exists(self.history_window):
            self.history_window.lift()                 # — Si ya existe la ventana de historial, la trae al frente
            self.refresh_history_window()             # — Y refresca su contenido
            return

        t = LANG[self.lang]
        self.history_window = tk.Toplevel(self.root)   # — Crea una nueva ventana hija (Toplevel) para el historial
        self.history_window.title(t["history_title"])  # — Título de la ventana de historial
        self.history_window.geometry("320x300")        # — Tamaño fijo de la ventana de historial
        self.history_window.resizable(False, False)

        frame = ttk.Frame(self.history_window)
        frame.pack(fill="both", expand=True, padx=8, pady=8)

        self.history_listbox = tk.Listbox(frame, height=12)
                                                     # — Listbox para mostrar entradas del historial
        scrollbar = ttk.Scrollbar(frame, orient="vertical", command=self.history_listbox.yview)
        self.history_listbox.config(yscrollcommand=scrollbar.set)
        self.history_listbox.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        btn_frame = ttk.Frame(self.history_window)
        btn_frame.pack(fill="x", pady=6)
        ttk.Button(btn_frame, text=t["btn_clear"], command=self.clear_history).pack(side="left", padx=6)
                                                     # — Botón para limpiar historial dentro de la ventana
        ttk.Button(btn_frame, text=t["btn_exit"], command=self.history_window.destroy).pack(side="right", padx=6)
                                                     # — Botón para cerrar la ventana de historial

        self.refresh_history_window()                   # — Inserta los elementos actuales del historial en el listbox
        self.history_listbox.bind("<Button-1>", self.copy_from_history)
                                                     # — Click simple copia el valor seleccionado al portapapeles
        self.history_listbox.bind("<Double-1>", self.load_seed_from_history)
                                                     # — Doble click carga la configuración (start/end/type/decimals)

    def refresh_history_window(self):
        t = LANG[self.lang]
        self.history_listbox.delete(0, tk.END)           # — Vacía el listbox
        if not self.history:
            self.history_listbox.insert(tk.END, t["history_empty"])
                                                     # — Si no hay historial, inserta texto "(historial vacío)"
        else:
            for idx, entry in enumerate(self.history, start=1):
                number_text = entry["number"] if isinstance(entry, dict) else str(entry)
                                                     # — Soporta entradas antiguas que podrían no ser dict (compatibilidad)
                self.history_listbox.insert(tk.END, f"{idx}. {number_text}")
                                                     # — Inserta "1. 42.00", "2. 7", etc.

    def clear_history(self):
        self.history.clear()                             # — Vacía la lista de historial en memoria
        if self.history_window and tk.Toplevel.winfo_exists(self.history_window):
            self.refresh_history_window()               # — Refresca la ventana si está abierta

    def copy_result(self):
        text = self.var_result.get()                     # — Toma el texto completo mostrado en resultado (p. ej. "Result: 5")
        parts = text.split(":", 1)                       # — Separa por ":" para extraer únicamente el valor
        value = parts[1].strip() if len(parts) > 1 else text.strip()
        if not value:
            return                                      # — Si no hay valor, no hace nada
        self.root.clipboard_clear()                      # — Limpia portapapeles del sistema
        self.root.clipboard_append(value)                # — Copia el valor al portapapeles

        self.var_result.set(f"{LANG[self.lang]['result']} {value} ✓")
                                                     # — Muestra un check temporal para feedback visual
        self.root.after(700, lambda: self.var_result.set(f"{LANG[self.lang]['result']} {value}"))
                                                     # — Después de 700ms quita el check (restaura texto)

    def copy_from_history(self, event):
        try:
            sel = self.history_listbox.curselection()    # — Índices seleccionados en el listbox
            if not sel:
                return
            idx = sel[0]
            if idx >= len(self.history):
                return
            value = str(self.history[idx]["number"])      # — Obtiene el número del historial seleccionado

            self.root.clipboard_clear()
            self.root.clipboard_append(value)

            self.var_result.set(f"{LANG[self.lang]['result']} {value} ✓")  # — Feedback visual con check
            self.root.after(700, lambda: self.var_result.set(f"{LANG[self.lang]['result']} {value}"))
        except Exception:
            pass                                         # — Silencia cualquier excepción producida al copiar

    def load_seed_from_history(self, event):
        try:
            sel = self.history_listbox.curselection()
            if not sel:
                return
            index = sel[0]
            if index >= len(self.history):
                return
            seed = self.history[index]                    # — Recupera el diccionario con la configuración guardada

            if not isinstance(seed, dict):
                return                                    # — Si no es dict, no intenta cargar (compatibilidad)

            self.var_start.set(str(seed["start"]))        # — Carga start en la entrada
            self.var_end.set(str(seed["end"]))            # — Carga end en la entrada
            self.type_var.set(seed["type"])               # — Selecciona el tipo (Integer/Decimal)
            self.var_decimals.set(str(seed["decimals"]))  # — Carga decimales

            t = LANG[self.lang]
            self.var_result.set(f"{t['result']} {seed['number']} (config loaded)")
                                                     # — Muestra texto indicativo "config loaded"
            self.root.after(1200, lambda: self.var_result.set(f"{t['result']} {seed['number']}"))
                                                     # — Después de 1.2s restaura el texto sin la nota
        except Exception:
            pass                                         # — Silencia excepciones (no informa al usuario)

def main():
    root = tk.Tk()                                     # — Crea la raíz de la aplicación Tk
    app = RandomGeneratorApp(root)                     # — Instancia la clase de la aplicación (construye UI)
    root.mainloop()                                    # — Bucle principal de eventos de Tkinter

if __name__ == "__main__":
    main()                                             # — Ejecuta `main` si el archivo se ejecuta como script
